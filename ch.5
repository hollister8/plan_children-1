import tensorflow as tf
import matplotlib.pyplot as plt
import numpy as np

fashion_mnist = tf.keras.datasets.fashion_mnist
(x_train, y_train),(x_test, y_test) = fashion_mnist.load_data()

class_names = ['T-shirt', 'Trouser', 'Pullover', 'Dress', 'Coat', 
               'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']

for i in range(25):
    plt.subplot(5, 5, i+1)
    plt.grid(False)
    plt.xticks([])
    plt.yticks([])
    plt.imshow(x_train[i], cmap=plt.cm.binary)
plt.show()

x_train, x_test = x_train / 255.0, x_test / 255.0

model = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(input_shape=(28,28)),
    tf.keras.layers.Dense(128, activation = 'relu'),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Dense(10, activation = 'softmax')
])
 
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

model.fit(x_train, y_train, epochs=5)
model.evaluate(x_test, y_test, verbose = 2)

for x in range(10):
    if x == 3:
        print('Found',x)
        break
else:
    print('End of loop. Not found')
    
for x in range(10):
    if 2<x<3:
        print('Found',x)
        break
else:
    print('End of loop. Not found')
    
for x in range(10):
    if 2<x<3:
        print('Found',x)
        break
    else:
        print('End of loop. Not found', x)
        
# for x in range(10):
#     if 2<x<3:
#         print('Found',x)
#         break
# elif:
#     print('End of loop. Not found')

import io
import re
import torch
from contextlib import redirect_stdout
from torchsummary import summary

f = io.StringIO()
with redirect_stdout(f):
    summary(squeezenet.cuda(), input_size=(3,224,224))
s = f.getvalue()

total_params = re.search('Total totlal_params:.*', s ).group()
input_size = re.search('Input size \(MB\):.*', s).group()
foward_backward_pass_size = re.search('Foward_backward_pass_size\(MB\):.*',s).group()
params_size = re.search('params_size\(MB\):.*',s).group()
estimated_total_size = re.search('Estimated_total_size\(MB\):.*',s).group()

print(total_params, input_size, foward_backward_pass_size, params_size, estimated_total_size, end='\n')

a = 256
print(a == 256)
print(a is 256)
print(id(a))
print(id(256))
b = 257
print(b == 257)
print(b is 257)
print(id(b))
print(id(257))

d = 17
print(d == 17)
print(d is 17)
print(id(d))
print(id(17))

e = 65536
print(e == 65536)
print(e is 65536)

import sys

print(sys.getsizeof(0.99999999999999999999999999999999999999999999999999999999999999999))
print('sosu')
print(sys.getsizeof(0))
print(sys.getsizeof(1))
print(sys.getsizeof(90))
print('sdfsdfsdf')
print(sys.getsizeof(1073741000))
print(sys.getsizeof(1073741823))
print('sdfsdfsdf')
print(sys.getsizeof(1073741824))
print('sdfsdfsdf')
print(sys.getsizeof(2 ** 30 -1))
print(sys.getsizeof(2 ** 30))
print(sys.getsizeof(2 ** 60 -1))
print(sys.getsizeof(2 ** 60))
print(sys.getsizeof(2 ** 90 -1))
print(sys.getsizeof(2 ** 90))
print(sys.int_info)

import dis
def add(a,b):
    c = a + b
    return c
r = add(10,20)
print(r, add.__code__.co_varnames)
dis.dis(add)

import dis
def add(a,b):
    return a+ b
r = add(10,20)
print(r, add.__code__.co_varnames)
dis.dis(add)

print(4 != 0 not in [1,2,3])
print((4 !=0) not in [1,2,3])
print(4 != 0 not in [0,1,2,3])
print((4 !=0) not in [0,1,2,3])

dis.dis('print(4 !=0 not in [1,2,3])')

0 LOAD_NAME: co_names[print]와 연관된 값을 스택으로 푸시합니다.
2 LOAD_CONST: co_consts[4]를 스택으로 푸시합니다
4 co_consts[0]를 스택으로 푸시합니다
6 DUP_TOP: 스택 최상단의 참조를 복제합니다.
8 ROT_THREE: 두 번째와 세 번째 스택 항목을 한 자리 위로 들어 올리고, 최상단 항목을 세 번째 자리로 내립니다.
10 COMPARE_OP: 불리언 연산을 수행합니다. 연산 이름은 cmp_op[!=]에서 찾을 수 있습니다.
12 JUMP_IF_FALSE_OR_POP: TOS가 거짓이면, 바이트 코드 카운터를 target으로 설정하고 스택에 TOS를 남겨 둡니다. 
                         그렇지 않으면 (TOS가 참이면), TOS가 팝 됩니다.
14 co_consts[(1, 2, 3)]를 스택으로 푸시합니다
16 불리언 연산을 수행합니다. 연산 이름은 cmp_op[not in]에서 찾을 수 있습니다.
18 JUMP_FORWARD: 바이트 코드 카운터를 delta만큼 증가시킵니다.
20 ROT_TWO: 두 개의 최상위 스택 항목을 자리바꿈합니다.
22 POP_TOP: 스택 최상단 (TOS) 항목을 제거합니다.
24 CALL_FUNCTION: 위치 인자를 사용하여 콜러블 객체를 호출합니다.
26 RETURN_VALUE: TOS를 함수 호출자에게 반환합니다.

dis.dis('print((4 !=0) not in [1,2,3])')

0 LOAD_NAME: co_names[print]와 연관된 값을 스택으로 푸시합니다.
2 LOAD_CONST: co_consts[4]를 스택으로 푸시합니다.
4 LOAD_CONST: co_consts[0]를 스택으로 푸시합니다.
6 COMPARE_OP: 불리언 연산을 수행합니다. 연산 이름은 cmp_op[!=]에서 찾을 수 있습니다.
8 LOAD_CONST: co_consts[(1,2,3)]를 스택으로 푸시합니다.
10 COMPARE_OP: 불리언 연산을 수행합니다. 연산 이름은 cmp_op[not in]에서 찾을 수 있습니다.
12 CALL_FUNCTION: 위치 인자를 사용하여 콜러블 객체를 호출합니다.

dis.dis('print(4 !=0 not in [0,1,2,3])')

0 LOAD_NAME: co_names[print]와 연관된 값을 스택으로 푸시합니다.
2 LOAD_CONST: co_consts[4]를 스택으로 푸시합니다
4 LOAD_CONST: co_consts[0]를 스택으로 푸시합니다
6 DUP_TOP: 스택 최상단의 참조를 복제합니다.
8 ROT_THREE: 두 번째와 세 번째 스택 항목을 한 자리 위로 들어 올리고, 최상단 항목을 세 번째 자리로 내립니다.
10 COMPARE_OP: 불리언 연산을 수행합니다. 연산 이름은 cmp_op[!=]에서 찾을 수 있습니다.
12 JUMP_IF_FALSE_OR_POP: TOS가 거짓이면, 바이트 코드 카운터를 target으로 설정하고 스택에 TOS를 남겨 둡니다. 
                         그렇지 않으면 (TOS가 참이면), TOS가 팝 됩니다.
14 co_consts[(0, 1, 2, 3)]를 스택으로 푸시합니다
16 불리언 연산을 수행합니다. 연산 이름은 cmp_op[not in]에서 찾을 수 있습니다.
18 JUMP_FORWARD: 바이트 코드 카운터를 delta만큼 증가시킵니다.
20 ROT_TWO: 두 개의 최상위 스택 항목을 자리바꿈합니다.
22 POP_TOP: 스택 최상단 (TOS) 항목을 제거합니다.
24 CALL_FUNCTION: 위치 인자를 사용하여 콜러블 객체를 호출합니다.
26 RETURN_VALUE: TOS를 함수 호출자에게 반환합니다.

dis.dis('print((4 !=0) not in [0,1,2,3])')

0 LOAD_NAME: co_names[print]와 연관된 값을 스택으로 푸시합니다.
2 LOAD_CONST: co_consts[4]를 스택으로 푸시합니다.
4 LOAD_CONST: co_consts[0]를 스택으로 푸시합니다.
6 COMPARE_OP: 불리언 연산을 수행합니다. 연산 이름은 cmp_op[!=]에서 찾을 수 있습니다.
8 LOAD_CONST: co_consts[(0,1,2,3)]를 스택으로 푸시합니다.
10 COMPARE_OP: 불리언 연산을 수행합니다. 연산 이름은 cmp_op[not in]에서 찾을 수 있습니다.
12 CALL_FUNCTION: 위치 인자를 사용하여 콜러블 객체를 호출합니다.
